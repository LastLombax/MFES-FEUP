class Execution

types
public string = seq of char;
public Category = <Pizza> | <SnacksDrinks> | <Candies> | <Pharmacy> | <Sushi>;
public State = <INIT> | <READY_FOR_DELIVER> | <CLOSED> ;

values
address1 : User`Address = mk_User`Address("as","as","as","as");
address2 : User`Address = mk_User`Address("as","bl","44","z9");

instance variables
private stores: seq of Store;
private products: seq of Product;
private couriers: seq of Courier;
private orders: seq of Order;

-- Users
user1 : User := new User("bernas@hotmail.com", address1);
user2 : User := new User("vitorino@hotmail.com", address2);
users : seq of User := [user1,user2];

-- Products
prod1A : Product := new Product("Rabanada", 2.5, "Rabanada de Convento", 5);
prod2A : Product := new Product("Bolina", 1.5, "Docinho de Bolina", 10);
prod3A : Product := new Product("Bolo Rei", 3.99, "Bolo Rei sem frutos", 6);
prodsA : seq of Product := [prod2A,prod3A];

prod1B : Product := new Product("Pizza Tropical", 10, "Pizza com ananas", 3);
prod2B : Product := new Product("Pizza Funghi", 7, "Pizza com cogumelos", 8);
prod3B : Product := new Product("Pizza Margherita", 6.5, "Pizza normal", 2);
prodsB : seq of Product := [prod2B,prod3B];

-- Stores
store1: Store := new Store("store1", <Candies>, "Candies Store", "10-15min", 1.5, prodsA);
store2: Store := new Store("store2", <Pizza>, "Papa Pizza", "10-30min", 5, prodsB);

-- Orders
order1: Order := new Order(user1);

operations

public Execution: () ==> Execution
Execution() == (
stores := []; products := []; couriers := []; users := []; orders := []; 
stores := stores ^ [store1,store2];
products := products ^ [prod1A, prod2A, prod3A];
users := users ^ [user1]; 
return self
);

public getUsers: () ==> seq of User
getUsers() == (
return users;
);

public getStores: () ==> seq of Store
getStores() == return stores;

public getCouriers: () ==> seq of Courier
getCouriers() == return couriers;

public getOrders: () ==> seq of Order
getOrders() == return orders;

public createOrder: string ==> string
createOrder(email) == (
for user in users do 
	if user.getEmail() = email then
		(
		dcl newOrder : Order := new Order(user);
		orders := orders ^ [newOrder]; 
		IO`println("New Order for " ^ user.getEmail()); 
		IO`print("Order ID "); IO`println(newOrder.getId()); 
		IO`println("Please add Products");
		return "success";
		) 
	else return "User doesn't exist.";
);

public addProductToOrder: string * int * string * int ==> int
addProductToOrder(email, orderId, storeName, productIndex) == (
for store in stores do
 if store.getName() = storeName then 
 (
 	dcl newProd : Product := store.getProduct(productIndex);
 	for order in orders do 
	if order.getId() = orderId then
		(
		if order.getUser().getEmail() = email then (order.addProduct(newProd));
		return 1;
		)  else return -1;
 )
	else return -1;
);


public populateDB: () ==> nat
populateDB() == (

return 1;
);

-- !USER --
-- see user information
-- list category
-- list stores by category
-- create order
-- cancel order
-- add product to order
-- close order

-- !ADMIN/ROBOT --
-- list all users
-- list all orders
-- list couriers
-- assign current orders to courier (closed orders)

-- !Courier --
-- list orders 
-- perform order
-- close order

 
functions
-- TODO Define functiones here
 traces
-- TODO Define Combinatorial Test Traces here
end Execution


-- create t := new Execution()
-- print t.getUser1().setPersonInfo("Teste", <Male>, 20)
-- print t.getUser1()
-- print t.getStore1().addProduct(t.getProduct1())