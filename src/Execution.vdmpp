class Execution

types
public string = seq of char;
public Category = <Pizza> | <SnacksDrinks> | <Candies> | <Pharmacy> | <Sushi>;


values
address1 : User`Address = mk_User`Address("as","as","as","as");
address2 : User`Address = mk_User`Address("as","bl","44","z9");

instance variables
private stores: seq of Store;
private products: seq of Product;
private couriers: seq of Courier;
private orders: seq of Order;
private refOrders: map int to int;
private users: seq of User;

-- Users
user0 : User := new User("blankuser", address1);
user1 : User := new User("bernas@hotmail.com", address1);
user2 : User := new User("vitorino@hotmail.com", address2);


-- Couriers
courier1 : Courier := new Courier("maria@glovo.com", 800);

-- Products
prod1A : Product := new Product("Rabanada", 2.5, "Rabanada de Convento", 5);
prod2A : Product := new Product("Bolina", 1.5, "Docinho de Bolina", 10);
prod3A : Product := new Product("Bolo Rei", 3.99, "Bolo Rei sem frutos", 6);
prodsA : seq of Product := [prod2A,prod3A];

prod1B : Product := new Product("Pizza Tropical", 10, "Pizza com ananas", 3);
prod2B : Product := new Product("Pizza Funghi", 7, "Pizza com cogumelos", 8);
prod3B : Product := new Product("Pizza Margherita", 6.5, "Pizza normal", 2);
prodsB : seq of Product := [prod2B,prod3B];

-- Stores
store1: Store := new Store("store1", <Candies>, "Candies Store", "10-15min", 1.5, prodsA);
store2: Store := new Store("store2", <Pizza>, "Papa Pizza", "10-30min", 5, prodsB);

-- Orders
order1: Order := new Order(user1);

operations

public Execution: () ==> Execution
Execution() == (
stores := []; products := []; couriers := []; users := []; orders := []; 
stores := stores ^ [store1,store2];
products := products ^ [prod1A, prod2A, prod3A];
couriers := couriers ^ [courier1]; 
refOrders := {0 |-> -1 };
users := users ^ [user1,user2];
return self
);

public performOrder: string * int ==> string
performOrder(courierID, orderID) == (
 dcl auxCourier : Courier ;
 dcl auxReturn: int ;
 for courier in couriers do  (if(courier.getcardID()=courierID) then auxCourier := courier; );
 for order in orders do (
 	if order.getId() = orderID then auxReturn := order.deliverOrder(courierID);
 	);
IO`print("Order: "); IO`println(orderID); 
IO`println("Order State: DELIVERED"); 
IO`println("By Courier: " ^ courierID); 
return "success";
)
pre (orderID in set dom refOrders);

public assignCourier: string * int ==> string
assignCourier(courierID, orderID) == (
 dcl auxCourier : Courier ;
 dcl auxReturn: int ;
 for courier in couriers do  (if(courier.getcardID()=courierID) then auxCourier := courier; );
 for order in orders do (
 	if order.getId() = orderID then auxReturn:=order.setCourier(auxCourier);
 	);
IO`print("Order: "); IO`println(orderID); 
IO`print("Assigned Courier: "); IO`println(courierID); 
return "success";
);

public getUsers: () ==> seq of User
getUsers() == (
return users;
);

public getStores: () ==> seq of Store
getStores() == return stores;

public getCouriers: () ==> seq of Courier
getCouriers() == return couriers;

public getOrders: () ==> seq of Order
getOrders() == return orders;

public getrefOrders: () ==> map int to int
getrefOrders() == (
return refOrders;
);

public listCouriers: () ==> string
listCouriers() == 
(
for courier in couriers do (IO`println("Courier ID: " ^ courier.getcardID()););
return "success";
);

public listUsers: () ==> string
listUsers() == 
(
for user in users do (IO`println("User Email: " ^ user.getEmail()););
return "success";
);
 
public createOrder: string ==> string
createOrder(email) == (
for user in users do (
		if user.getEmail() = email then
			(
			dcl newOrder : Order := new Order(user);
			orders := orders ^ [newOrder]; 
			refOrders := refOrders ++ {newOrder.getId() |-> len orders - 1};
			IO`println("New Order for " ^ user.getEmail()); 
			IO`print("Order ID "); IO`println(newOrder.getId()); 
			IO`println("Please add Products");
			return "success";
			) 
		);
	return "User doesn't exist.";
);

public cloneProd: Product * nat ==> Product
cloneProd(refProd, numberUnits) == (
dcl newProd : Product := new Product(refProd.getName(), refProd.getPrice(), refProd.getDescription(), numberUnits);
return newProd;
);

public addProductToOrder: string * int * string * int * nat ==> string
addProductToOrder(email, orderId, storeName, productIndex, numberUnits) == (
for store in stores do (
 if store.getName() = storeName then 
 (
 	dcl auxRet : int ;
 	dcl refProd : Product := store.getProduct(productIndex); 
 	dcl newProd : Product := cloneProd(refProd, numberUnits);
 	-- remove numberUnits from Product Store
 	dcl newStock : nat := refProd.removeStock(numberUnits);
 	for order in orders do (
		if order.getId() = orderId then
			(
			if order.getUser().getEmail() = email then (auxRet := order.addProduct(newProd););
			IO`println("Product(s) added. Current Order:"); 
			for prod in order.getProducts() do (IO`print(prod.getName() ^ ". Quantity: "); IO`println(prod.getStock())); 
			return "success";
			)  
		);
 ) );
	return "error";
);

public concludeOrder: string * int ==> string
concludeOrder(email, orderId) == (
for order in orders do (
		if order.getId() = orderId then
			(
			dcl auxRet : int ;
			if order.getUser().getEmail() = email then (auxRet := order.finishOrder());
			IO`println("Order Concluded. Bill:"); 
			for prod in order.getProducts() do (IO`print(prod.getName() ^ ". Quantity: "); IO`print(prod.getStock()); IO`print(" Unit Price: "); IO`println(prod.getPrice()));
			IO`print("Total: "); IO`println(order.getTotalCost()); 
			return "success";
			)
		);

	return "error";
);

public populateDB: () ==> nat
populateDB() == (

return 1;
);

-- !USER --
-- see user information
-- list category
-- list stores by category
-- create order
-- cancel order
-- add product to order
-- close order

-- !ADMIN/ROBOT --
-- list all users
-- list all orders
-- list couriers
-- assign current orders to courier (closed orders)

-- !Courier --
-- list Courier orders 
-- Perform Order (Close order)
-- close order

 
functions
-- TODO Define functiones here
 traces
-- TODO Define Combinatorial Test Traces here
end Execution

-- create t := new Execution()
-- print t.createOrder("bernas@hotmail.com")
-- print t.addProductToOrder("bernas@hotmail.com",1000,"store1",1,1)
-- print t.concludeOrder("bernas@hotmail.com",1000)
-- print t.assignCourier("maria@glovo.com",1000)
-- print t.performOrder("maria@glovo.com",1000)
-- print t.getUser1().setPersonInfo("Teste", <Male>, 20)
-- print t.getUser1()
-- print t.getStore1().addProduct(t.getProduct1())