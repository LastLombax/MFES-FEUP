class Execution

types
public string = seq of char;

values
address1 : User`Address = mk_User`Address("as","as","as","as");
address2 : User`Address = mk_User`Address("as","bl","44","z9");

instance variables
private stores: seq of Store;
private products: seq of Product;
private couriers: seq of Courier;
private orders: seq of Order;
private refOrders: map int to int;
private users: seq of User;
private categories: set of string;


-- pre not exists user in set elems users & user.email= em; TODO: addUser

-- Users
user0 : User := new User("blankuser", address1);
user1 : User := new User("bernas@hotmail.com", address1);
user2 : User := new User("vitorino@hotmail.com", address2);

-- Couriers
courier1 : Courier := new Courier("maria@glovo.com", 800);

-- Products
prod1A : Product := new Product("Rabanada", 2.5, "Rabanada de Convento", 5);
prod2A : Product := new Product("Bolina", 1.5, "Docinho de Bolina", 10);
prod3A : Product := new Product("Bolo Rei", 3.99, "Bolo Rei sem frutos", 6);
prodsA : seq of Product := [prod2A,prod3A];

prod1B : Product := new Product("Pizza Tropical", 10, "Pizza com ananas", 3);
prod2B : Product := new Product("Pizza Funghi", 7, "Pizza com cogumelos", 8);
prod3B : Product := new Product("Pizza Margherita", 6.5, "Pizza normal", 2);
prodsB : seq of Product := [prod2B,prod3B];

-- Stores
store1: Store := new Store("store1", "candies", "Candies Store", "10-15min", 1.5, prodsA);
store2: Store := new Store("store2", "pizza", "Papa Pizza", "10-30min", 5, prodsB);

-- Orders
order1: Order := new Order(user1);

operations

public Execution: () ==> Execution
Execution() == (
stores := []; products := []; couriers := []; users := []; orders := []; 
stores := stores ^ [store1,store2];
products := products ^ [prod1A, prod2A, prod3A];
couriers := couriers ^ [courier1]; 
refOrders := {0 |-> -1 };
users := users ^ [user1,user2];
categories :=  {"pizza", "snacks", "candies", "pharmacy", "sushi"};
IO`println("Welcome to feup-Glovo App! Made by MFES Brothers."); 
IO`println("Here is what you can do:"); 
IO`println("List Categories : print t.listCategories()");
IO`println("List Stores : print t.listStores(CategoryName)");
IO`println("List Products of Store : print t.listStoreProducts(StoreName)");
IO`println("List Orders : print t.listOrders(request) -> request can be all or UserEmail");
IO`println("List Users : print t.listUsers()");
IO`println("List Couriers : print t.listCouriers()");
IO`println("Create an Order : print t.createOrder(name@mail.com)");
IO`println("Add Product to Order : print t.addProductToOrder(name@mail.com,OrderID,storeName,productIndex,numberUnits)");
IO`println("Finish your order: print t.concludeOrder(name@mail.com,OrderID)");
IO`println("Assign a Courier to your order: print t.assignCourier(courier@glovo.com,OrderID)");
IO`println("Perform an Order: print t.performOrder(courier@glovo.com,OrderID)");
return self
);

public addUser: string * string * string * string * string ==> string
addUser(email, address, street, zip_code, country) == (
dcl newAddress : User`Address := mk_User`Address(address,street,zip_code,country);
dcl newUser : User := new User(email, newAddress);
users := users ^ [newUser];
return "Result: User added to Users list.";
);

public addCourier: string * int ==> string
addCourier(idCard, salary) == (
dcl newCourier : Courier := new Courier(idCard, salary);
couriers := couriers ^ [newCourier];
return "Result: Courier added to Couriers list.";
);

public performOrder: string * int ==> string
performOrder(courierID, orderID) == (
 dcl auxCourier : Courier ;
 dcl auxReturn: int ;
 for courier in couriers do  (if(courier.getcardID()=courierID) then auxCourier := courier; );
 for order in orders do (
 	if order.getId() = orderID then auxReturn := order.deliverOrder(courierID);
 	);
IO`print("Order: "); IO`println(orderID); 
IO`println("Order State: DELIVERED"); 
IO`println("By Courier: " ^ courierID); 
return "Result: success";
)
pre (orderID in set dom refOrders
 and exists1 order in set elems orders & order.orderID = orderID
 and exists1 courier in set elems couriers & courier.cardID = courierID
 and order.state = <ORDER_CONCLUDED> 
 and order.courier.cardID = courierID
 )
post exists order in set elems orders & (order.orderID = orderID and order.state = <DELIVERED>);

public assignCourier: string * int ==> string
assignCourier(courierID, orderID) == (
 dcl auxCourier : Courier ;
 dcl auxReturn: int ;
 for courier in couriers do  (if(courier.getcardID()=courierID) then auxCourier := courier; );
 for order in orders do (
 	if order.getId() = orderID then auxReturn:=order.setCourier(auxCourier);
 	);
IO`print("Order: "); IO`println(orderID); 
IO`print("Assigned Courier: "); IO`println(courierID); 
return "Result: success";
)
pre exists1 order in set elems orders & (order.orderID = orderID and (order.courier = nil or order.courier.cardID <> courierID) and order.state = <ORDER_CONCLUDED>)
 and exists1 courier in set elems couriers & courier.cardID = courierID
post exists1 order in set elems orders & (order.orderID = orderID and order.courier.cardID = courierID);
 
public createOrder: string ==> string
createOrder(email) == (
for user in users do (
		if user.getEmail() = email then
			(
			dcl newOrder : Order := new Order(user);
			orders := orders ^ [newOrder]; 
			refOrders := refOrders ++ {newOrder.getId() |-> len orders - 1};
			IO`println("New Order for " ^ user.getEmail()); 
			IO`print("Order ID "); IO`println(newOrder.getId()); 
			IO`println("Please add Products");
			return "Result: success";
			) 
		);
	return "User doesn't exist.";
)
pre exists user in set elems users & user.email = email;

public cloneProd: Product * nat ==> Product
cloneProd(refProd, numberUnits) == (
dcl newProd : Product := new Product(refProd.getName(), refProd.getPrice(), refProd.getDescription(), numberUnits);
return newProd;
);

public addProductToOrder: string * int * string * int * nat ==> string
addProductToOrder(email, orderId, storeName, productIndex, numberUnits) == (
for store in stores do (
 if store.getName() = storeName then 
 (
 	dcl auxRet : int ;
 	dcl refProd : Product := store.getProduct(productIndex); 
 	dcl newProd : Product := cloneProd(refProd, numberUnits);
 	-- remove numberUnits from Product Store
 	dcl newStock : nat := refProd.removeStock(numberUnits);
 	for order in orders do (
		if order.getId() = orderId then
			(
			if order.getUser().getEmail() = email then (auxRet := order.addProduct(newProd););
			IO`println("Product(s) added. Current Order:"); 
			for prod in order.getProducts() do (IO`print(prod.getName() ^ ". Quantity: "); IO`println(prod.getStock())); 
			return "Result: success";
			)  
		);
 ) );
	return "error";
)
pre exists1 order in set elems orders & (order.orderID = orderId and order.state = <INIT>);

public concludeOrder: string * int ==> string
concludeOrder(email, orderId) == (
for order in orders do (
		if order.getId() = orderId then
			(
			dcl auxRet : int ;
			if order.getUser().getEmail() = email then (auxRet := order.finishOrder());
			IO`println("Order Concluded. Bill:"); 
			for prod in order.getProducts() do (IO`print(prod.getName() ^ ". Quantity: "); IO`print(prod.getStock()); IO`print(" Unit Price: "); IO`println(prod.getPrice()));
			IO`print("Total: "); IO`println(order.getTotalCost()); 
			return "Result: success";
			)
		);

	return "error";
)
pre exists1 order in set elems orders & (order.orderID = orderId and order.state = <INIT>)
	and exists1 user in set elems users & user.email = email
post exists order in set elems orders & (order.orderID = orderId and order.state = <ORDER_CONCLUDED>);

public populateDB: () ==> nat
populateDB() == (

return 1;
);

-- 																										<LISTING OPERATIONS>
-- "all" for all orders and "email" for user orders
public listOrders: string  ==> string
listOrders(request) == 
(
if request = "all" then for order in orders do
(
IO`print("Order ID: "); IO`println(order.getId());
IO`print("State of Order: "); IO`println(order.getState());
IO`print("Client: "); IO`println(order.getUser().getEmail());
IO`println("Products (if any): ");
if len order.getProducts() > 0 then 
(for product in order.getProducts() do (IO`print("Product: " ^ product.getName() ^ ". Units: "); IO`println(product.getStock())););
);

if request <> "all" then for order in orders do
(
if (order.getUser().getEmail() = request) then (
IO`print("Order ID: "); IO`println(order.getId());
IO`print("State of Order: "); IO`println(order.getState());
IO`print("Client: "); IO`println(order.getUser().getEmail());
IO`println("Products (if any): ");
if len order.getProducts() > 0 then 
(for product in order.getProducts() do (IO`print("Product: " ^ product.getName() ^ ". Units: "); IO`println(product.getStock()));););
);


IO`println("\n");
return "Result: success";
);
--category existe

public listCategories: () ==> string
listCategories() == 
(
for all category in set categories do (
IO`println("Category: " ^ category);
);
return "Result: success";
);
--category existe

public listStores: string ==> string
listStores(categoryName) == 
(
IO`println("Stores with Category: " ^ categoryName);
for store in stores do (
	if store.getCategory() = categoryName then (IO`println("Store: " ^ store.getName()); return "Result: success")
);
return "Result: error on listing store";
)
pre categoryName in set categories;

public listStoreProducts: string ==> string
listStoreProducts(storeName) == 
(
dcl auxProducts : seq of Product ;
dcl countProds : int := 0;

IO`println("Products of: " ^ storeName);
	for store in stores do (
		if store.getName() = storeName then auxProducts := store.getProducts();
	);
	
	for auxProd in auxProducts do (
		IO`print(countProds); IO`println(" Name: " ^ auxProd.getName() ^ ". Description: " ^ auxProd.getDescription());
		IO`print("Unit Price: " ); IO`println(auxProd.getPrice());
		countProds:=countProds+1;
	);
	
return "Result: success";
)
pre exists1 store in set elems stores & store.name = storeName;

public listCouriers: () ==> string
listCouriers() == 
(
for courier in couriers do (IO`println("Courier ID: " ^ courier.getcardID()););
return "Result: success";
)
pre couriers <> [];

public listUsers: () ==> string
listUsers() == 
(
for user in users do (IO`println("User Email: " ^ user.getEmail()););
return "Result: success";
)
pre users <> [];

-- 																										<GET OPERATIONS>

public getUsers: () ==> seq of User
getUsers() == return users
post RESULT = users;

public getStores: () ==> seq of Store
getStores() == return stores
post RESULT = stores;

public getCouriers: () ==> seq of Courier
getCouriers() == return couriers
post RESULT = couriers;

public getOrders: () ==> seq of Order
getOrders() == return orders
post RESULT = orders;

public getrefOrders: () ==> map int to int
getrefOrders() == return refOrders
post RESULT = refOrders;

-- !USER --
-- see user information
-- list category
-- list stores by category
-- create order
-- cancel order
-- add product to order
-- close order

-- !ADMIN/ROBOT --
-- list all users
-- list all orders
-- list couriers
-- assign current orders to courier (closed orders)

-- !Courier --
-- list Courier orders 
-- Perform Order (Close order)
-- close order

 
functions
-- TODO Define functiones here
 traces
-- TODO Define Combinatorial Test Traces here
end Execution

-- create t := new Execution()
-- print t.createOrder("bernas@hotmail.com")
-- print t.addProductToOrder("bernas@hotmail.com",XXXX,"store1",1,1)
-- print t.concludeOrder("bernas@hotmail.com",XXXX)
-- print t.assignCourier("maria@glovo.com",XXXX)
-- print t.performOrder("maria@glovo.com",XXXX)
-- print t.getUser1().setPersonInfo("Teste", <Male>, 20)
-- print t.getUser1()
-- print t.getStore1().addProduct(t.getProduct1())